# go-encrypt-sending

# 流程说明

本程序采用 rc4 对信息进行加密，rc4 所使用的密钥由 DH 算法进行协商，同时使用预先储存的公钥对所有发送的消息进行签名认证。

## 步骤说明

为方便说明情况：定义以下名称
- 随机数 `r1` `r2`
- `hash(x)` 为 x 的哈希值
- `sign(x)` 为对 x 的签名
- `CA_P` 为预先定义的公钥，同理，`CA_S` 为私钥
- `DH_P` 为 diffie-hellman 协商过程中使用的公钥，同理，`DH_S` 为私钥

1. 客户端向服务端发送 `r1`，同时，`hash(r1)` 将作为本机的识别码
2. 服务端生成 `r2`，并对 `hash(r1+r2)` 使用 `CA_S` 进行签名，即 `S = sign(hash(r1+r2))`，向客户端发送 S 与 r2
3. 客户端验证后生成 `DH_P (client)` ，并向服务端发送使用 `CA_P` 加密的 素数P 与 整数G 与 `DH_P (client)`
4. 服务端解密后生成 `DH_P (server)` 与 `DH_S`，同时向客户端发送使用 `DH_S` 签名的 `DH_P (server)`
5. 客户端根据服务端的 `DH_P (server)` 生成 `DH_S`
6. 至此，密钥协商与身份认证完成，此后所有消息皆使用 `DH_S` 进行加密。
   - 在接下来的沟通中，服务端对客户端的所有消息皆使用 `CA_S` 进行签名，客户端对服务端的所有消息使用 `DH_S` 进行签名。
   - 所有的签名皆对加密后的消息进行，即先加密后签名。

## 防中间人攻击原理解析

- 在 1-2 步中，若中间人 m 截获了消息 r1，并向服务端发送伪造的消息 r1，则该过程可简述如下：
  1. client --> m: r1 ; m --> server: r1_fake;
  2. server --> m: sign(hash(r1_fake+r2)), r2; m --> client: sign(hash(r1+r2))_fake
  3. client: sign(hash(r1+r2)) != sign(hash(r1+r2))_fake
  4. 发现中间人攻击，链接终止
- 在第 3 步中，中间人无法解密使用 `CA_P` 加密的消息，故后面的步骤皆无法进行

